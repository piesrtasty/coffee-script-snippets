##########
#
# Searching
#
##########

###

This chapter introduces new functional programming concepts and
their use in problem solving.

Problem #1

Write a program that finds the shortest route between two
points on Hiva Oa.

The first aspect of this problem is representing our data.

What does our program need to know?

1. Which locations are connected.
2. How long the roads between them are.

* The places and roads form a mathemati
cal graph

How do we store this graph?

1. A simple possibility is to store an array of road objects,
   each of which contains properties naming its two endpoints and
   its length.

###

roads = [
	{ point1: 'Point Kiukiu', point2: 'Hanaiapa', length: 19 }
	{ point1: 'Point Kiukiu', point2: 'Mt Feani', length: 15 } 
]

###

However, it turns out that the program, while working out a route,
will likely need to get a list of all the raods taht start at
a certain location.

###

roads = 
	'Point Kiukiu': [	{to: 'Hanaiapa', distance: 19 }
										{to: 'Mt Feani', distance: 15 }
										{to: 'Taaoa', distance: 15 } ]
	'Taaoa': 				[	] # et cetera

###

When using the above data structure, getting all roads that leave
from Point Kiukiu is just a matter of looking up that key in
the roads object: roads['Point Kiukiu']

The above data structure however contains duplicate information.

We can specify the roads once, and have the correct data structure
be generated by the computer. First intialize an empty object
called 'roads', and write a function 'makeRoad'.

###

roads = {}
makeRoad = (from, to, length) ->
	addRoad = (from, to) ->
		roads[from] = [] if not (from of roads)
		raods[from].push to: to, distance: length
	addRoad from, to
	addRoad to, from

###

The if statment in 'addRoad' makes sure that there is an array
of destinations associated with the location named by 'from',
if there is not one it puts in an empty array. This way, the next
line can asume there is such an array and safely push the new road
onto it.

Now the map information looks like this:

###

makeRoad 'Point Kiukiu', 'Hanaiapa', 19
makeRoad 'Point Kiukiu', 'Mt Feani', 15
makeRoad 'Point Kiukiu', 'Taaoa', 15
show roads

###

In the above description the string 'Point Kiukiu' still
occurs three times in a row. We could make our description
even more succinct by allowing multiple roads to be specified
in one line.

Write a function 'makeRoads' that takes any uneven number
of arguments. The first argument is always the starting point
of the roads, and every pair of argumenys that gives an ending
point and a distance.

Do not duplicate the functionality of 'makeRoad', but have
'makeRoads' call 'makeRoad' to do the actual road-making.

###

makeRoads = (start) ->
	for i in [1..arguments.length] by 2
		makeRoad start, arguments[i], arguments[i + 1]

# This function uses one named parameter, 'start', and gets
# the other paramters from the arguments (quasi) array. 'i'
# starts at 1 becuase it has to skip this first parameter.
# 'by 2' skips the distances.

# You can verify the solution with this code that builds a
# data structure matching the map of Hiva Oa.

roads = {}
makeRoads 'Point Kiukiu',
	'Hanaiapa', 19, 'Mt Feani', 15, 'Taaoa', 15
makeRoads 'Airport',
	'Hanaiapa', 6, 'Mt Feani', 5,
	'Atuona', 4, 'Mt Ootua', 11
makeRoads 'Mt. Temetiu',
	'Mt. Feani', 8, 'Taaoa', 4
makeRoads 'Atuona',
	'Taaoa', 3, 'Hanakee pearl lodge', 1
makeRoads 'Cemetery',
	'Hanakee pearl lodge', 6, 'Mt Ootua', 5
makeRoads 'Hanapaoa',
	'Mt Ootua', 13, 'Point Teohhotepapapa', 14
show 'Roads from the airport'
show roads['Airport'];

###

we considerably shortened our description by defining some new convenient operations. When, at any time
tou find yourself writing repetitive or redundant code, stop and try to come up with a vocabularly that makes
it shorter and denser.

Now passing a key of the city's name to the road's object will
return an array of all the roads leaving it. However a typo
in the key's name will result in 'undefined' being returned
due to the nature of the data structure.

We will implement a wrapper function to retrieve the roads
array and handle the possible undefined error.

###

roadsFrom = (place) ->
	found = roads[place]
	return found if found?
	throw new Error "No place named '#{place}' found."

try
	show roadsFrom "Hanaiapa"
	show roadsFrom "Hanalapa"
catch error
	show "Ooops #{error}"

###

Next is our first attempt at implementing a path-finding
algorithm, "the gambler's method".

###

gamblerPath = (from, to) ->

	randomInteger = (below) ->
		Math.floor Math.random() * below

	randomDirection = (from) ->
		options = roadsFrom from
		options[randomInteger(options.length)].to

	path = []
	loop
		path.push from
		break if from == to
		from = randomDirection from
	path

show gamblerPath 'Hanaiapa', 'Mt Feani'

###

Better way to solve this problem -> "generate and test"

1. Generate all possible routes
2. In this set, find the shortest one that actually connects
	 the start to the end point.

Additional vocabulary / functions we will need...

###

### 

Member - used to determine whether an element is found
				 within an array.

* The route will be kept as an array of names, and upon
  arrival at a new place the algorithm could call _member
  to check whether have been to this place already.

###

_member = (array, value) ->
	found = false
	array.forEach (element) ->
sfdbcb                                                                                                		if element == value
				found = true
	found

show _member [6, 7, "Bordeaux"], 7


###

However, a problem exists. Tne above function will continue
to iterate over the entire array even if we find the matching
value.

* When using a "for" loop you can use a "break" statement
  to exit out of it, however in a "forEach" construct this
  does not work because the body of the loop is a function,
  and break statements cannot jump out of functions.

One solution -> Modify "forEach" to recognize a certain kind
of exceptions as signalling a break. i.e.....

###

_break = toString: -> "Break"

_forEachh = (array, action) ->
	try
		for element in array
			action element
	catch exception
		if exception != _break
			throw exception

show _forEach [1..3], (n) -> n*n
# Which btw could in CoffeeScript be written as
show (i*i for i in [1..3])

###
a
If the action function throws _break, _forEach will stop
looping. The object stored in the variable break is used
purely for comparison . It was given a 'toString' property
such that it might be usefuk to figure out what kind of a
strange value you are dealing with if you somehow
end up with _break exceptio outside of a _forEach loop.

Now we can define _member as follows:

###

_member = (array, value) ->
	found = flasea
	_forEach array, (element) ->
		if element == value
			found = true
			throw _break
	found

###

This function exists in Underscpre as "include" or "contains"
But being it is such a common operation it is built into 
CoffeeScript with the "in" operator. (i.e. for...in). Using
"in" is the preferred way to trst for aray membership.

###

show 7 in [6, 7, "Bordeaux"]

###

Although being able to break out of _forEach loops is useful,
in the case of the _member function the result is still rather
ugly, as we need to specifically store the result in order
to later return it.

One solution is to add another exceotion, _return, which can be
given a 'value' property, and have _forEach return this
value when said exception is thrown. However this solution
is rather ad-hoc and messy.

The best solution is create  a brand new, higher-order, function,
called 'any' (or sometimes 'some').

* It exists in Underscore under both names. It looks essentially
like the following...

###

_any = (array, test) ->
	for element in array
		if test element
			return true
	false

# Using Underscore
show any [3, 4, 0, -3, 2, 1], (n) -> n < 0

# Redefining member with any
_member = (array, value) ->
	partial = (func, a...) -> (b...) -> func a..., b...
	any array, partial ((a, b) -> a == b), value
show _member ["Fear", "Loathing"], "Denial"

###

'any' goes over the elements in an array, from left to right,
and applies the test function to them. The first time this
returns a true-ish value, it returns that value. If no
true-ish value is found, flase is returned. Calling
any(test, array) is more or less equivalent to doing
test(array[1] || ... etcetera.

Just like && is the companion of ||, 'any' has a companion
called 'every'.

###

_every = (array, test) ->
	for element in array
		if not test element
			return false
		true
	show every [1 ,2, -1], (n) -> n != 0 # Using Underscore

###

Another function we will need is 'flatten'. This function takes an array of arrays, and puts 
the elements of the arrays together in one big array.

###

_fatten = (array) ->
	result = []
	for element in array
		if isArray element
			result = result.concat _flatten element
		else	
			result.push element
	result

# Using Underscore
show flatten [[1], [2, [3, 4]]], [5,6]]

###

Before starting to generate routes, we need one more higher-order function. This one is called
'filter' (in Underscore it is also named select). Like map, it takesa function and an array as arguments, and
produces a new array, but instead of putting the reuslts of calling the function in the new array, it produces an array
with only those values from the old array for which the given function returns a true-like value. Write a 
'_filter' function that shows it works.

###

_filter = (array, test) ->
	result = []
	for element in array
		if test element
			result.push element
	result

show _filter [0, 4, 8, 12], (n) -> n < 5

isOdd = (n) -> n % 2 != 0
show filter [0..6], is Odd # Using Underscore

###

Imagine what an algorithm to generate routes would like it -- it starts at the 
starting locagtion, and starts to generate a route for every road leaving therere. At the end
of each of these roads it continues to generate more routes. Because of this, recursion is a natural way
to model it.

###

possibleRoutes = (from, to) ->
	findRoutes = (route) ->
		notVisited = (road) ->
			not (road.to in route.places)
		continueRoute = (road) ->
			findRoutes
				places: route.places.concat([road.to]),
				length: route.length + road.distance
		end = route.places[route.places.length - 1]
		if end == to
			[route]
		else
			flatten map filter(roadsFrom(end), notVisited, continueRoute)


	show (possibleRoutes 'Point Teohhotepapapa', 'Point Kiukiu').length

	show possibleRoutes 'Hanapaoa', 'Mt Ootua'

###

The function returns an array of route objects, each of which contains an array of places that
the route passes, and a length. findRoutes recursibely continues a route, returning an array with
extension of that route. When the end of a route is is the place where we want to go, it just returns that
route, since continuing past that place would be pointless. If it is another place. we must go on. The flatten
/map/filter line is probably the hardest to read. It is saying...

"Take all the roads going from the current location, discard the ones that go to places which will gie an array of
finished routes for each of them, then put all these routes into a single big array that we return."

Does this not recurse forever? No, at some point all outgoing roads will be go to places that a route has already
passsed, and the result of filter will be an empty array. Mapping over an empty array produces an empty array, and flattening
that still gives an empty array. So calling findRoutes on a dead end produces an empty array, meaning 'there are no
ways to continue at this point'.

* Notice that places are appended to routes by using concat, not push. The concat method creates a new array, while push
modifies the existing array. Because the function must not modify the array that represents the original route, because it must
be used several times.

Now that we have all possible routes, let us try to find the shorted one. Write a function shortestRoute that, like 
possibleRoutes, takes the names of a starting and ending location as arguments. It returns a single route object, of
the type that possibleRoutes produces.

###

shortestRoute = (from, to) ->
	currentShortest = null
	forEach possibleRoutes(from, to), (route) ->
			if not currentShortest or
					currentShortest.length > route.length
				currentShortest = route
		currentShortest

###

The tricky thing in 'minimising' or 'maximizing' algorithms is to not screw up when given an
empty array. In this case, we happen to know that here is at least one road between every 2 places, so we could
just ignore it. But that would be lame. What if the road from Puamua to Mount Ootua, which is steep and muddy, is
washed away by a rainstorm? It would be a shame if this caused our function to break as well. so it takes care to return
null when no routes are found.

Then, the very functional, abstract-everything-we-can approach:

###

minimise = (func, array) ->
	minScore = null
	found = null
	forEach array, ( (element) ->
		score = func element
		if minScore == null || score < minScore
			minScore = score
			found = element )
	found

getProperty = (propName) ->
	(object) -> object[propName]

shortestRoute = (from, to) ->
	minimise getProperty('length')
					 possibleRoutes(from, to)

### 

Unfortunately, it is two times longer than the other version. In programs where you need to minimise several
things it might be a good idea to write the generic algorithm like this, so you can re-use it. In most cases the first
version is probably good enough.

Note the getProperty function though, it is often useful when doing functional programming with objcts.

Let us see what route are algorithm comes up with between Point Kiukiu and Point Teohotepapapa....

###

show (shortestRoute 'Point Kiukiu', 
	'Point Teohotepapapa').places


###

On a small island like Hiva Oa, it is not too much work to generate all possible routes. If you try to do
that on a reasonably detailed map of, say, Belgium, it is going to take an absurdly long time.

IF we start comparing routes while we are building them, we can avoid building this big set of routes, and,
as soon as we have found a single route to our destination, we can stop extending routes that are already longer than
that route.

We will use a 20 x 20 grid as our map...

The area is divided into squares with a size of a hundred meters. We have at our disposal a function heightAt, which
will gibe us the height, in meters, or any square on that map, where squares are represented by object with x and
y properties.

show heightAt x: 0, y: 0
show heightAt x: 11, y:18

We want to cross this landcape, on foot, from the top left to the bottom right. A grid can can be approached like a
graph. Every square is a node, which is connected to the squares around it.

We do not like wasting energy, so we would prefer to take the easiest route possible. Going uphill is heavier than
going downhill, and going downhill is heaver thatn going level. This function calculates the amound of weighted meters
betwen two adjacent squares, which represents how tired you get from walking (or climbing) between them. Goijg
uphill is counted twice as heavy as going downhill.

###

weightedDistance = (pointA, pointB) ->
	heightDifference =
		heightAt(pointB) - heightAt(pointA)
	climbFactor = if heightDifference < 0 and 1 else 2
	flatDistance = 
		if pointA.x == pointB.x or pointA.y == pointB.y
			100
		else
			141
	flatDistance + climbFactor * Math.abs heightDifference

show weightedDistance(x: 0, y: 0), (x: 1, y: 1)

###

Note the 'flatDistance' calculation. If the two points are on the same row or column, they are right next to
each other, and the distance between them is a hundred meters. Otherwise, they are assumed to be diagonally adjacent,
abd the diagonal distance btween two squares of this size is a hundred times the squre root of two, which is
approximately 141. One is not allowed to call this function for squares that are further than one step
apart. 

Points on the map are represented by objects containing x and y properties. These three functions are
useful when working with such objects.


###

point = (x, y) -> {x, y} # Same as {x: x, y: y}

addPoints = (a, b) -> point a.x + b.x, a.y + b.y

samePoint = (a, b) -> a.x == b.x and a.y == b.y

show samePoint addPoints(point(10, 10), point(4, -2)),
												 point(14, 8)

###

If we are going to find routes through this map, we will again need a function to create 'signposts',
lists of directions that can be taken from a given point. Write a function 'possibleDirections', whuch takes a point
obhect as argument and returns an array of nearby points. We can only move to adjacent points, both straight and
diagonally, so squares have a maximum of eight neighbors. Take care not to return the squares that lie outside of the ma.
For all we know the edge of the map might be the edge of the world.

###

possibleDirections = (from) ->
	mapSize = 20
	insideMap = (point) ->
		point.x >= 0 and point.x < mapSize and
		point.y >= 0 and point.y < mapSize
	directions = [ point(-1,  0), point( 1, 0)
								 point( 0, -1), point( 0, 1)
								 point(-1, -1), point(-1, 1)
								 point( 1, 1), point( 1, -1)]
	partial = (func, a...) -> (b...) -> func a..., b...
	filter (map directions,
							partial addPoints, from), insideMap

show possibleDirections point 0, 0

###

I created a variable mapSize, for the sole purpose of not having to write 20 two times. If, at some other time, we want
to use this same function for another map, it would be clumsy if the code as full of 20s, whuch all have to be changed.
We could even go sas far as making the mapSize an argument to possibleDirections, we can use the function for 
different maps without changing it. I judged that that was not necessary in this case, such things can be changed when
the need arises. Then why did I not add a variable to hold the 0, which also occurs two times? I assumed that
maps always start at 0, so this one is unliklely to ever change, and using a variable for it only adds noise.

To find a route on this map without having our browsesr cut off the program because it takes to long to finish, we
have to stop our amateurish attempts and implement a serious algorithm. A lot of work has gone into problems like
this in the past, and many solutions have been designed (some brilliant, others useless.) A very popular and efficient
one is called A*. We will spend the rest of the chapter implementing an A* route-finding function for our map.

The trouble with searching routes through graphs is  that, in big graphs, there are an awful lot of them. Our Hiva
Oa pathfinder showed that, when the graph is small, all we needed to do was to make sure our paths did not
revisit points they had already passed. On our new map, this is not enough anymore.

The fundamental problem is that there's too much room for going int the wrong direction. Unless we somehow
manage to steer our exploration of paths towards the goal, a choice we make for continuing a given path is more likely
to go in the wrong direction than in the right direction. If you keep generating paths like that, you end up with
an enormous amount of paths, and even if one of them accidentally reaches the end point, you do not know whtether that is
the shortest path.

So what you want to do is explore directions that are likely to get you to the end point first. On a grid like our
map, you can get a rough estimate of how goood a path is by checking how long it is and how close its end is to
the end point. By adding path length and an estimate ofthe distance it still has to go, you can get a rough idea of which
paths are promising. If you extend promising paths first, you are less likmely to waste time on useless ones.

But still that is not enough. If our map was of a perfectly flat plane, the path that looked promising would almost
always be the best one, and we could use the above method to walk right to our goal. But we have valleys and hillsides
blocking our paths, so it is hard to tell in advance which direction will be the most efficient panth. Because of this,
we still end up having to explore way too many paths.

To correct this, we can make clever use of the fact that we are constantly exploring the most promising path first. Once we have determined
that path A is the best way to get to point X, we can remember that. When later om, path B
also gets to point X, we know that it is not the best route, so we do not have to explore it
further. This can prevent our program from building a lot of pointles paths.

The algorithm then goes something like this...

There are two pieces of data to keep track of. The first one is called the open list,
it contains partial routes that must still be explored. Each route has a score, which is
calculated by adding its length to its estimated distance from the goal. This estimate must
alwyas be optimistic, it should nevder overestimate distance. The second is a set of nodes
that we have seen, together with the shorted partial route that ghot us there. This one we will
call the reached list. We start by adding a route that contains only the starting node to the open
list, and recording it in the reached list.

Then, as long as there are any nodes in the open list, we take out the one that has the 
lowest (best) score, and find ways in which it can be continued (by calling possibleDirections). For each
of the nodes this returns, we create a new route by appending it to our original route, and
adjusting the length of the route usint weightedDistance. The endpoint of each of these
new routes is then looked up in the reached list.

If the node is not in the reached list yet, it means we have not seen it before, and we add
the new route to the open list and record it in the reached list. If we had seen it before,
we compare the score of the new route to the score of the route in the reached list. If the new
route is shorter, we replace the existing route with the new one. Otherwise, we discard the new route,
since we already seen a better way to get to that point.


We continue doing this until the route we fetch from the open list ends at the goal node, in
which case we have found our route, or until the open list is empty, in which case we have found
out that there is no route. In our case the map contains no unsurmountable obstacles, so there is always a
route.

How do we know that the first full route that we get from the open list is also the shortest one?
This is a result of the fact that we only look at a route when it has the lowest score. The score of a route
is its actual length plus an optimistic estimate of the remaining length. This means that if a route
has the lowest score in the open list, it is always the best route to its current
endpoint -- it is impossible for another route to later find a better way to that point,
because if it were better, its score would have been lower.	

Try not to get frusturated when the fine points of why this works are still eluding you.
When thinking about algorithms like this, having seen 'something like it' beforre helps
a lot, it gives you a point of reference to compare the approach to. Beginning programmers
have to do without such a point of reference, which makes it rather easy to get lost. Just
realise that this is advanced stuff, globally read over the the rest of the chapter, and
come back to it later when you feel like a challenge.

I am afraid, that for one aspect of the algorithm, I am going to have to invoke magic again.
The open list needs to be able to hold a large amount of routes, and to quickly find the route
with the lowest score among them. Storing them in a normal array, and searching through this array
every time, is way too slow, so I give you a data structure called a binary heap. You
crearte them with new, just like Date objects, giving them a function that is used to 'score'
its elements as argument. The resulting object has the methods push and pop, just like an array, but pop
always gives you the element with the lowest score, instead of the one that was pushed last.

###

bh = require './A2-BinaryHeap'
globalize bh

heap = new BinaryHeap()
forEach [2, 4, 5, 1, 6, 3], (number) ->
	heap.push number

while heap.size() > 0
	show heap.pop()

###

The need to squeeze out as much efficiency as we can has another effect. The Hiva Oa
algorithm used arrays of locations to store routes, and copied them with the concat
method when it extended them. This time, we can not afford to copy array, since we will be
exploring lots and lots of routes. Instead, we usea  a 'chain' of objects to store a route.
Every object chain has some properties, such as a point on the map, and the length of the
route so far, and it also has a property that points at the previous object in the chain.

Where the blue circles are the relevant objects, and the lines represent properties -- the
end points are the values of the property. Object A is the start of a route here. Object B is
used to build a new route, which continues from A. It has a property, which we will call
'from', pointing at the route it is based on. When we need to reconstruct a route later, we can
follow these properties to find all the points that the route passed. Note that object B is
part of two routes, one that ends in D and one that ends in E. When there are a lot ofroutes,
this can save us much storage space -- every new route only needs one new object for itself,
the rest is shared with other routes that started the same way.

Write a function 'estimatedDistance' that gives an optimistic estimate of the distance between two points.
It does not have to look at the height data, but can assume a flat map. Remember that we are only
travelling straight and diagonally, and that we are counting the diagonal distance between
two squares as 141.

###

estimatedDistance = (pointA, pointB) ->
	dx = Math.abs pointA.x - pointB.x
	dy = Math.abs pointA.y - pointB.y
	if dx > dy
		(dx - dy) * 100 + dy * 141
	else
		(dy - dx) * 100 + dx * 141

show estimatedDistance point(3,3), point(9, 6)

###

The strange formulae are used to decompose the path into a straight and a diagonal part.
If you have a path like this...the path is 6 squares wides and 3 high, so you get 6 - 3 = 3 straight
moves, and 3 diagonal ones.

If you wrote a function that just computes the straight 'Pythagorean' distance
between the points, that would also work. What we need is an optimistic estimate, and 
assuming you can go straight to the goal is certainly optimistic. However, the closer the
estimate is to the real distance, the less useless paths our program has to try out.

WE will use a binary heap for the open list. What would be a good data structure for the
reached list? This one will be used to look up routes, given a pair of x, y coordinates.
Preferably in a way that is fast. Write three functions, 'makeReachedList', 'storeReaded',
and 'findReached'. The first one creates your data structure, the second one, given a reached
list, a point, and a route, stores a route in it, and the last one, given a reached list and
point, retrieves a route or returns undefined to indicate that no route was found for that point.

One reasonable idea would be to use an object with objects in it. One of the coordinates in the
points, say x, is used a a property name for the outer object, and the other, y, for the inner
object. This does require some bookkeeping to handle the fact that, sometimes, the inner object
we are looking for is not there (yet).

###

makeReachedList = -> {}

storeReached = (list, point, route) ->
	inner = list[point.x]
	if inner is undefined
		inner = {}
		list[point.x] = inner
	inner[point.y] = route

findReached = (list, point) ->
	inner = list[point.x]
	if inner is undefined
		undefined
	else
		inner[point.y]

###

Another possibility is to merge the x and y of the point into a single property name,
and use that to store routes in a single object.

###

pointID = (point) ->
	point.x + '-' + point.y

makeReachedList = -> {}
storeReached = (list, point, route) ->
	list[pointID(point)] = route
findReached = (list, point) ->
	list[pointID(point)]

### 

Defining a type of data structure by providing a set of functions to create and manipulate
such sturctures is a useful technique. It makes it possible to 'isolate' the code that makes
use of the structure from the details of the structure itself. Note that, no matter which of the
above two implementations is used, code that needs a reached list works in exactly the same
way. It does not care what kind of objects are used, as long as it gets the results it expected.

This will be discussed in much more detail in Object Orientation, where we will learn to make
object types like BinaryHeap, which are created using new and have methods to manipulate them.

Here we finally have the acctual path-finding function:

###

findRoute = (from, to) ->

	routeScore = (route) ->
		if route.score is undefined
			route.score = route.length + estimatedDistance route.point, to route.score

	addOpenRoute = (route) ->
		open.push route
		storeReached reached, route.point, route

	open = new BinaryHeap routeScore
	reached = makeReachedList()
	addOpenRoute point: from, length: 0

	while open.size() > 0
		route = open.pop()
		if samePoint route.point, to
			return route

		forEach possibleDirections(route.point),
			(direction) ->
				known = findReached reached, direction
				newLength = route.length + weightedDistance route.point, direction
			if not known or known.length > newLength
				if known
					open.remove known
				addOpenRoute
					point: direction,
					from:  route,
					length: newLength
	return null

###

First it creates the data structures it needs, one open list and one reached list.
routeScore is the scoring function given to the binary heap. Note how it stores its result
in the route object, to prevent haivng to re-calculate it multiple times.

addOpenRoute is a convenienve functions that adds a new route to both the open list and the
reached list. It is immediately used to add the start of the route. Note that route objects always have
the properties point, which holds the point at the end of the route, and length, which holds the
current length of the route. Routes which are more than one square long also have a from property, whuch
points at their predescessors.

The while loop, as was described in th algorithm, keeps takign the lowest scoring route from the
open list and checks whether this gets us to the goal point. If it does not, we must continue by 
expanding it. This is what the forEach takes care of. It looks up this new point in the
reached list. If it is not found there, or the node found has a longer length than that of the new
route, a new route object is created and added to the open list and reached list, and the existing
route (if any) is removed from the open list.

What if the route in known is not on the open list? It has to be, because routes are only
removed from the open list when they have been found to be the most optimal route to their
endpoint. If we try to remove a value from a binary heap that is not on it, it will throw
an exception, so if my reasoning is wrong, we will probably see an exception when running the
function.

Whenb code gets complex enough to make you doubt certain things about it, it is a good idea
to add some checks that raise exceptions when something goes wrong. That way, you know that
there are no weird things happening 'silently', and when you break something, you immediately see what you
broke.

Note that this algorithm does not use recursion, but still manages to explore all those branches. The open list
more or less takes over the role taht the function call stack played in the recursive solution to the 
Hiva Oa problem -- it keeps track of the paths that still have to be explored. Every 
recursibe algorithm can be rewritten in a non-recursive way by using a data structure to store
the 'things that must still be done'.

Well, let us try out path-finder:

###

route = findRoute point(0, 0), point(19, 19)

###

If you ran all the code above, and did not introduce any errors, that call, thought it might
take an instant to run, should gibe us a route object. This object is rather hard to read. That
can be helped by using the 'showRoute' function which will show a route as a list of coordinates

###

showRoute route

### 

You can also pass multiple routes to showRoute, which can be useful when you are, for example, trying
to plan a scenic route, which must include the beautiful viewpoint at 11, 17.

###

showRoute findRoute(point( 0, 0), point(11, 17)),
					findRoute(point(11,17), point(19, 19))

###

You can also display routed on a map with renderRoute. A web page with the map is served
to your browser, the the route points are transferred via WebSockets to a snippet of
CoffeeScript on the page that uses a canvas to draw the points on top of the map.

###

renderRoute findRoute(point( 0, 0), point(11, 17)),
					findRoute(point(11,17), point(19, 19))

###

Variations on the theme of searching an optimal route through a graph can be applied to many problems,
many of which are not at all related to findinf a physical path. For example, a program that
needs to solve a puzzle of fitting a number of blocks into a limited space could do this by exploring
the various 'paths' it gets by trying to put a certain block in a certain place. The paths that ends up with
insufficient room for the last blocks are dead ends, and the path that manges to fit in all bloks
is the solution.